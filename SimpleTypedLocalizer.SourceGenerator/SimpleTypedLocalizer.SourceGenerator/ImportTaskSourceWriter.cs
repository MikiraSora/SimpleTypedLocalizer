using System;
using System.Linq;
using System.Text;

namespace SimpleTypedLocalizer.SourceGenerator;

public static class ImportTaskSourceWriter
{
    public static string GenerateExtensionClass(LocalizeImportTaskContext context, RunTaskContextResult result)
    {
        var codeBuilder = new IndentedStringBuilder();
        codeBuilder
            .AppendLine("// <auto-generated />")
            .AppendLine($"// generated time: {DateTime.Now}")
            .AppendLine("using System;")
            .AppendLine("using System.Globalization;")
            .AppendLine("using System.Collections.Generic;")
            .AppendLine("using System.CodeDom.Compiler;")
            .AppendLine("using System.Diagnostics.CodeAnalysis;")
            .AppendLine("using System.Text;")
            .AppendLine("using SimpleTypedLocalizer;")
            .AppendLine();

        if (!string.IsNullOrWhiteSpace(context.TargetNameSpace))
            codeBuilder
                .AppendLine($"namespace {context.TargetNameSpace};")
                .AppendLine();

        codeBuilder
            .AppendLine("[GeneratedCode(\"SimpleTypedLocalizer\", \"0.0.1\")]")
            .AppendLine($"{context.TargetClassAccessibility} partial class {context.TargetClassName}")
            .AppendLine("{")
            .IncrementIndent();

        codeBuilder
            .AppendLine(
                "private static readonly LocalizerManager manager = new LocalizerManager(new LocalizedTextProvider[]{")
            .IncrementIndent();

        GenerateLocalizedTextProvider(result, codeBuilder);

        codeBuilder
            .DecrementIndent()
            .AppendLine("});")
            .AppendLine();

        GenerateLocalizedTextProperties(context, result, codeBuilder, false);
        codeBuilder.AppendLine();

        codeBuilder
            .AppendLine("public static LocalizerManager LocalizerManager => manager;")
            .AppendLine();

        var firstExampleTextName = result.ExportLocalizedTextNames.FirstOrDefault().Key;
        if (!string.IsNullOrWhiteSpace(firstExampleTextName))
        {
            codeBuilder
                .AppendLine(
                    "/// it's nestest class which contains text sources that implement INotifyPropertyChanged and design for data binding")
                .AppendLine("/// <example><code>")
                .AppendLine(
                    $"/// &lt;TextBlock Text=\"{{Text, Source={{x:Static lang:{context.TargetClassName}.B.{firstExampleTextName}}}}}\"/&gt;")
                .AppendLine("/// </code></example>");

            codeBuilder
                .AppendLine("public static class B")
                .AppendLine("{")
                .IncrementIndent()
                .AppendLine("// avoid compiler trim this nested class in AOT.")
                .AppendLine(
                    $"static B(){{LocalizerManager.OnChangedCultureInfo+=()=>{{var _ = {firstExampleTextName}.Text;}};}}")
                .AppendLine("");

        GenerateLocalizedTextProperties(context, result, codeBuilder, true);

        codeBuilder
            .DecrementIndent()
            .AppendLine("}")
            .AppendLine();
        }

        GenerateStaticBuildProviders(result, codeBuilder);

        codeBuilder
            .DecrementIndent()
            .AppendLine("}")
            .AppendLine();

        return codeBuilder.ToString();
    }

    private static void GenerateStaticBuildProviders(RunTaskContextResult result,
        IndentedStringBuilder codeBuilder)
    {
        foreach (var staticBuildProvider in result.StaticBuildProviders)
            GenerateStaticBuildProvider(codeBuilder, staticBuildProvider);
    }

    private static void GenerateStaticBuildProvider(IndentedStringBuilder codeBuilder,
        RunTaskContextResult.StaticBuildProvider staticBuildProvider)
    {
        codeBuilder
            .AppendLine($"private static class {staticBuildProvider.ProviderClassName}")
            .AppendLine("{")
            .IncrementIndent();

        codeBuilder
            .AppendLine(
                $"public static readonly LocalizedTextProvider Instance = new LocalizedTextProvider(CultureInfo.GetCultureInfo(\"{staticBuildProvider.ProviderLangCode}\"),")
            .AppendLine("new Dictionary<string, string>(){")
            .IncrementIndent();

        foreach (var pair in staticBuildProvider.LangMap)
            codeBuilder.AppendLine(
                $" [\"{pair.Key}\"] = Encoding.UTF8.GetString(Convert.FromBase64String(\"{Convert.ToBase64String(Encoding.UTF8.GetBytes(pair.Value))}\"))  ,");

        codeBuilder
            .DecrementIndent()
            .AppendLine("});");

        codeBuilder
            .DecrementIndent()
            .AppendLine("}")
            .AppendLine();
    }

    private static string EscapeLineBreaks(string input)
    {
        if (string.IsNullOrEmpty(input)) return input;
        return input.Replace("\r\n", "\\n").Replace("\n", "\\n");
    }

    /// <summary>
    ///     123123
    /// </summary>
    private static void GenerateLocalizedTextProperties(LocalizeImportTaskContext context, RunTaskContextResult result,
        IndentedStringBuilder codeBuilder, bool isGenerateTextSource)
    {
        foreach (var pair in result.ExportLocalizedTextNames)
        {
            var typeName = isGenerateTextSource ? "ILocalizedTextSource" : "string";
            var methodName = isGenerateTextSource ? "GetLocalizedTextSource" : "GetLocalizedText";

            var textName = pair.Key;

            var textDefaultValue = EscapeLineBreaks(pair.Value);

            codeBuilder.AppendLine("/// <summary>");
            codeBuilder.AppendLine(
                $"/// get localized text {(isGenerateTextSource ? "source " : "")}named <c>{textName}</c>, default localized value: <c>{textDefaultValue}</c><br/>");

            codeBuilder.AppendLine("/// </summary>");
            codeBuilder.AppendLine(
                $"public static {typeName} {textName} => manager.{methodName}(nameof({textName}));");
        }
    }

    private static void GenerateLocalizedTextProvider(RunTaskContextResult result,
        IndentedStringBuilder codeBuilder)
    {
        foreach (var declareSourceSentence in result.ProviderDeclareSourceSentences)
            codeBuilder.AppendLine(declareSourceSentence + ",");
    }
}